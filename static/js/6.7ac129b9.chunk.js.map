{"version":3,"sources":["pages/GraphPage.module.css","utils/makeTimeHumanReadable.ts","utils/insertIfExists.ts","pages/GraphPage.tsx","utils/useFetcher.ts"],"names":["module","exports","input","ms","s","Math","floor","m","h","msString","toFixed","slice","sString","mString","hString","text","delim","putDelimiterBefore","fetcher","fetchWrapper","a","userId","categoryId","levelId","searchParams","Promise","all","SPEEDRUN_COM_URL","insertIfExists","entries","map","key","value","data","values","label","categoryData","userData","runsData","levelData","subcategoryArr","runs","filter","run","status","Object","every","subcategoryKey","get","date","DateTime","fromFormat","zone","time","times","primary_t","id","sort","first","second","gameName","game","names","international","categoryName","name","subcategoryString","join","username","levelName","GraphPage","useParams","theChart","useRef","URLSearchParams","useLocation","search","error","useFetcher","loading","chartData","labels","datasets","borderColor","chartOptions","onClick","current","activeElements","getActiveElements","length","index","window","location","href","responsive","scales","x","type","tooltipFormat","y","ticks","callback","makeTimeHumanReadable","plugins","tooltip","callbacks","tooltipItem","parsed","to","className","styles","chartContainer","ref","options","forceReload","useState","setData","setLoading","setError","cache","useContext","CacheContext","isInCache","addOrUpdateCache","getFromCache","url","cacheKey","replace","fetchJsonp","timeout","dataRaw","json","fetchData","newData","console","message","useEffect"],"mappings":"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","file":"static/js/6.7ac129b9.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"chartContainer\":\"GraphPage_chartContainer__3hmoX\"};","export default (input: number): string => {\n    const ms = input % 1;\n    const s = Math.floor(input) % 60;\n    const m = Math.floor(input / 60) % 60;\n    const h = Math.floor(input / 3600);\n\n    // the else of the ternary produces 0.xxx, so the slice(1) call produces .xxx\n    const msString = ms < .001 ? \"\" : ms.toFixed(3).slice(1);\n\n    const sString = s < 10 ? `0${s}` : `${s}`;\n\n    const mString = m < 10 ? `0${m}` : `${m}`;\n    const hString = h === 0 ? \"\" : `${h}:`;\n\n    return `${hString}${mString}:${sString}${msString}`;\n};\n","export default (text: string|undefined, delim: string, putDelimiterBefore?: boolean): string => \n    putDelimiterBefore\n        ? (text ? delim + text : \"\") \n        : (text ? text + delim : \"\");\n","import React, { FC, useRef } from \"react\";\nimport { useLocation, useParams } from \"react-router\";\nimport { SPEEDRUN_COM_URL } from \"../App\";\nimport { Line} from \"react-chartjs-2\";\nimport \"chartjs-adapter-luxon\";\nimport { DateTime } from \"luxon\";\nimport { Link } from \"react-router-dom\";\nimport { ErrorAlert, LoadingAlert } from \"../components/Alerts\";\nimport { EmbedGame, SRCCategory, SRCLevel, SRCResult, SRCRun, SRCUser, SRCVariable } from \"../types/SRCQueryResults\";\nimport {Chart, ChartOptions, TooltipItem} from \"chart.js\";\nimport makeTimeHumanReadable from \"../utils/makeTimeHumanReadable\";\nimport useFetcher, { Fetcher } from \"../utils/useFetcher\";\nimport insertIfExists from \"../utils/insertIfExists\";\nimport styles from \"./GraphPage.module.css\";\n\ninterface FetchedData {\n    gameName: string;\n    categoryName: string;\n    levelName: string;\n    subcategoryString: string;\n    username: string;\n    runs: {\n        date: DateTime;\n        time: number;\n        id: string;\n    }[];\n}\n\ninterface FetcherInput {\n    userId: string;\n    categoryId: string;\n    levelId?: string;\n    searchParams: URLSearchParams;\n}\n\nconst fetcher: Fetcher<FetcherInput,FetchedData> = async ({userId, categoryId, levelId, searchParams}, fetchWrapper) => {\n    const [categoryData, userData, runsData, levelData, subcategoryArr] = await Promise.all([\n        fetchWrapper<SRCResult<SRCCategory & EmbedGame>>(`${SPEEDRUN_COM_URL}/categories/${categoryId}?embed=game`),\n        fetchWrapper<SRCResult<SRCUser>>(`${SPEEDRUN_COM_URL}/users/${userId}`),\n        fetchWrapper<SRCResult<SRCRun[]>>(`${SPEEDRUN_COM_URL}/runs?user=${userId}${insertIfExists(levelId, \"&level=\", true)}&category=${categoryId}&max=200`),\n        levelId ? fetchWrapper<SRCResult<SRCLevel>>(`${SPEEDRUN_COM_URL}/levels/${levelId}`) : null,\n\n        // load all of the subcategories\n        Promise.all([...searchParams.entries()].map(async ([key,value]: [string,string]) : Promise<string> => {\n            const data = await fetchWrapper<SRCResult<SRCVariable>>(`${SPEEDRUN_COM_URL}/variables/${key}`);\n    \n            return data.data.values.values[value as string].label;\n        }))\n    ]);\n    \n    const runs = runsData.data\n        .filter(run=> run.status.status !== \"rejected\")\n        // only accept runs of the suggested subcategory\n        .filter(\n            run=> \n                Object.entries(run.values).every(\n                    ([subcategoryKey, subcategoryValue] :[string, string]) => \n                        subcategoryValue as string === searchParams.get(subcategoryKey)\n                )\n        )\n        .map(run => ({\n            date: DateTime.fromFormat(run.date, \"yyyy-MM-dd\", {zone: \"UTC\"}), \n            time: run.times.primary_t,\n            id: run.id\n        }))\n        // sort the runs, otherwise it will play connect the dots\n        .sort((first, second) => (\n            first.date === second.date\n                ? (first.time < second.time ? -1 : 1)\n                : (first.date < second.date ? -1 : 1)               \n        ));\n\n    return {\n        gameName: categoryData.data.game.data.names.international,\n        categoryName: categoryData.data.name,\n        subcategoryString: subcategoryArr.join(\", \"),\n        username: userData.data.names.international,\n        levelName: levelData ? levelData.data.name : \"\", \n        runs\n    };\n};\n\nconst GraphPage: FC = () => {\n    const {userId, categoryId, levelId} = useParams<{userId?: string; categoryId?: string; levelId?: string}>();\n\n    const theChart = useRef<Chart| null>(null);\n\n    const searchParams = new URLSearchParams(useLocation().search);\n\n    if(!userId)\n        return <ErrorAlert error=\"No user id provided!\"/>;\n    if(!categoryId)\n        return <ErrorAlert error=\"No category id provided!\"/>;\n        \n    const [data, loading, error] = useFetcher(fetcher, {userId, categoryId, levelId, searchParams});\n    if(error) return <ErrorAlert error={error} />;\n    if(loading) return <LoadingAlert/>;\n\n    const chartData = {\n        labels: data?.runs.map(run=>run.date),\n        datasets: [{\n            label: \"Time\",\n            data: data?.runs.map(run=>run.time),\n            borderColor: \"rgb(255,0,0)\",\n        }]\n    };\n\n    const onChartClick = () => {\n        // somehow the user clicked on the chart before the ref was set... shouldn't be possible\n        if(!theChart.current) return;\n        const activeElements = theChart.current.getActiveElements();\n        if(activeElements.length > 0) {\n            const run = data?.runs[activeElements[0].index];\n            window.location.href = `https://speedrun.com/run/${run?.id}`;\n        }\n    };\n\n    const chartOptions: ChartOptions = {\n        onClick: onChartClick,\n        responsive: true,\n        scales: {\n            x: {\n                type: \"time\",\n                time: {\n                    tooltipFormat: \"MMM d, yyyy\"\n                }\n            },\n            y: {\n                ticks: {\n                    // if this isn't a number we're *really* fucked\n                    callback: (value: number| string) => makeTimeHumanReadable(value as number)\n                }\n            }\n        },\n        plugins: {\n            tooltip: {\n                callbacks: {\n                    label: (tooltipItem: TooltipItem<\"line\">) => makeTimeHumanReadable(tooltipItem.parsed.y)\n                }\n            }\n        }\n    };\n\n    return (\n        <>\n            <h1>{data?.gameName}: {insertIfExists(data?.levelName,\" \")}{data?.categoryName} - {insertIfExists(data?.subcategoryString, \" - \")}{data?.username}</h1>\n            <Link to={`/user/${userId}`} >Back to user</Link>\n            <p><b> Click a data-point to see the associated run&apos;s speedrun.com page!</b></p>\n            <div className={styles.chartContainer}>\n                <Line ref={theChart} type='line' data={chartData} options={chartOptions} />\n            </div>\n        </>\n    );\n};\n\nexport default GraphPage;","import fetchJsonp from \"fetch-jsonp\";\nimport React, { useEffect, useState, useContext } from \"react\";\nimport { SPEEDRUN_COM_URL } from \"../App\";\nimport { Cache, CacheContext } from \"./CacheProvider\";\n\nexport type FetchWrapper = <T>(url: string) => Promise<T>;\n\nexport type Fetcher<InType,OutType> = (input: InType, fetchWrapper: FetchWrapper) => Promise<OutType>;\n\nexport default <InType,OutType>(\n    fetcher: Fetcher<InType, OutType>, \n    input: InType, forceReload?: React.DependencyList\n) : [OutType|null, boolean, string|null] => {\n    const [data, setData] = useState<OutType|null>(null);\n    const [loading, setLoading] = useState<boolean>(true);\n    const [error, setError] = useState<string|null>(null);\n\n    const cache = useContext<Cache|null>(CacheContext);\n\n    if(!cache) return [\n        null, \n        false, \n        \"calls to useFetcher() must be wrapped in a CacheProvider\"\n    ]; \n\n    const {isInCache, addOrUpdateCache, getFromCache} = cache;\n\n    const fetchWrapper =  async <T>(url: string): Promise<T> => {\n        const cacheKey = url.replace(SPEEDRUN_COM_URL,\"\");\n        if(isInCache(cacheKey)) {\n            // we dont have to worry about cache invalidation because the whole\n            // cache gets discarded on user refresh\n            return getFromCache<T>(cacheKey);\n        }\n\n        const dataRaw = await fetchJsonp(url, {timeout: 10000}); \n        const data = await dataRaw.json<T>();\n\n        addOrUpdateCache(cacheKey, data);\n\n        return data;\n    };\n\n    const fetchData = async () => {\n        setLoading(true);\n        try {\n            const newData = await fetcher(input, fetchWrapper);\n            setData(newData);\n            setLoading(false);\n        } catch (e) {\n            console.error(e);\n            setError(e.message);\n        }\n    };\n\n    useEffect(() => {fetchData();}, forceReload ?? []);\n\n    return [data, loading, error];\n};\n"],"sourceRoot":""}